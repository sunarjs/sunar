---
title: Middlewares
description: Explore how Sunar enhances your discord bot's functionality with middleware support.
---

Explore how Sunar enhances your discord bot's functionality with middleware support.

## Protectors

Protectors in Sunar act as middleware, allowing you to intercept and control the flow of commands and interactions within your Discord bot. They provide a flexible way to enforce permissions, validate inputs, or perform pre-processing before executing commands.

<Steps>
<Step>
### Create the protector logic

Create a file `only-admins.js` in the directory `src/protectors/`. This file defines a protector `onlyAdmins` that checks if the user has administrator permissions.

```js title="src/protectors/only-admins.js"
import { Protector, execute } from 'sunar';
import { PermissionFlagsBits } from 'discord.js';

const onlyAdmins = new Protector({
	commands: ['slash'],
	signals: ['interactionCreate'],
});

function isAdmin(permissions) {
	if (!permissions) return false;
	return permissions.has(PermissionFlagsBits.Administrator);
}

execute(onlyAdmins, (arg, next) => {
	const content = 'This command can only be used by administrators';

	if (Array.isArray(arg)) {
		const interaction = arg[0];

		if (isAdmin(interaction.memberPermissions)) return next();

		if (!interaction.isRepliable()) return;

		interaction.reply({ content, ephemeral: true });
	}

	if (arg.isChatInputCommand()) {
		if (isAdmin(arg.memberPermissions)) return next();
		return arg.reply({ content, ephemeral: true });
	}
});

export { onlyAdmins };
```

<Callout>
When creating a `Protector` instance, specify the commands, signals, or components that will use this protector. This allows precise control over the arguments received through function parameters.
</Callout>

</Step>

<Step>
### Create a protected command

Create a file `protected.js` in the directory `src/commands/`. This file defines a Slash command named `protected` that is protected by the `onlyAdmins` protector. Only administrators can execute this command, and it replies with a message indicating the user is an administrator.

```js title="src/commands/protected.js"
import { Slash, execute, protect } from 'sunar';

import { onlyAdmins } from '../protectors/only-admins.js';

const slash = new Slash({
	name: 'protected',
	description: 'This is a protected slash command',
});

protect(slash, [onlyAdmins]); // [!code highlight]

execute(slash, (interaction) => {
	interaction.reply({ content: 'You are an admin!' });
});

export { slash };
```

</Step>

</Steps>

### File structure

Here's an overview of the project's file structure to help you visualize how files are organized in this example.

<Files>
	<Folder name="src" defaultOpen>
		<Folder name="commands" defaultOpen>
			<File name="protected.js" />
		</Folder>
		<Folder name="protectors" defaultOpen>
			<File name="only-admins.js" />
		</Folder>
		<File name="index.js" />
	</Folder>
</Files>

## Accepts

Accepts in Sunar offer a fast and straightforward method to add basic restrictions to commands. They function like protectors but with simpler syntax, making them ideal for enforcing permissions and other basic requirements without needing to write complete middleware functions.

<Callout title="In development" type="warn">
	Validation failure handling is currently not supported directly by `accepts` in
	Sunar. For the moment, it is recommended to use protectors.
</Callout>

```js title="src/commands/remove-role.js"
import { Slash, accepts, execute } from 'sunar';
import {
	ApplicationCommandOptionType,
	PermissionFlagsBits,
	Role,
} from 'discord.js';

const slash = new Slash({
	name: 'remove-role',
	description: 'Remove a role',
	dmPermission: false,
	defaultMemberPermissions: [PermissionFlagsBits.ManageRoles],
	options: [
		{
			name: 'target',
			description: 'Target role',
			type: ApplicationCommandOptionType.Role,
			required: true,
		},
	],
});

accepts(slash, { // [!code highlight]
	clientPermissions: ['ManageRoles'], // [!code highlight]
}); // [!code highlight]

execute(slash, async (interaction) => {
	const role = interaction.options.getRole('target', true);

	if (!(role instanceof Role)) {
		return interaction.reply({ content: 'Invalid role.' });
	}

	if (!role.editable) {
		return interaction.reply({ content: "I don't have enough permissions." });
	}

	await role.delete();

	interaction.reply({ content: `**${role.name}** deleted.` });
});

export { slash };
```
The `accepts` mutator in this example configures permissions that a command or interaction (`slash` in this case) requires from the client (your bot) before allowing it to execute. Specifically, it ensures that the bot has the `ManageRoles` permission before allowing the `slash` command to be executed. This helps enforce necessary permissions for secure and controlled bot interactions in Discord.